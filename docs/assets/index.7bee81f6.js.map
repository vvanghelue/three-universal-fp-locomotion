{"version":3,"file":"index.7bee81f6.js","sources":["../../vite/dynamic-import-polyfill","../../src/input/xr/xr-input.js","../../src/input/mobile/mobile-input.js","../../src/input/input-system.js","../../src/_helpers/wait-until.js","../../src/collisions/collisions.js","../../src/locomotion/systems/climb-vr/climb-vr.js","../../src/locomotion/systems/fly-vr/fly-vr.js","../../src/locomotion/locomotion.js","../../src/locomotion/systems/walk/walk.js","../../src/index.js","../../examples/example1.js","../../src/locomotion/systems/snap-turn-vr/snap-turn-vr.js","../../src/_helpers/rotate-about-point.js"],"sourcesContent":["const p = function polyfill(modulePath = '.', importFunctionName = '__import__') {\n    try {\n        self[importFunctionName] = new Function('u', `return import(u)`);\n    }\n    catch (error) {\n        const baseURL = new URL(modulePath, location);\n        const cleanup = (script) => {\n            URL.revokeObjectURL(script.src);\n            script.remove();\n        };\n        self[importFunctionName] = (url) => new Promise((resolve, reject) => {\n            const absURL = new URL(url, baseURL);\n            // If the module has already been imported, resolve immediately.\n            if (self[importFunctionName].moduleMap[absURL]) {\n                return resolve(self[importFunctionName].moduleMap[absURL]);\n            }\n            const moduleBlob = new Blob([\n                `import * as m from '${absURL}';`,\n                `${importFunctionName}.moduleMap['${absURL}']=m;`\n            ], { type: 'text/javascript' });\n            const script = Object.assign(document.createElement('script'), {\n                type: 'module',\n                src: URL.createObjectURL(moduleBlob),\n                onerror() {\n                    reject(new Error(`Failed to import: ${url}`));\n                    cleanup(script);\n                },\n                onload() {\n                    resolve(self[importFunctionName].moduleMap[absURL]);\n                    cleanup(script);\n                }\n            });\n            document.head.appendChild(script);\n        });\n        self[importFunctionName].moduleMap = {};\n    }\n};__VITE_IS_MODERN__&&p(\"assets/\");","import * as THREE from \"three\"\nimport { inputSystem } from \"../input-system\"\nimport waitUntil from \"../../_helpers/wait-until\"\nimport { Camera } from \"three\"\nimport handsModel from \"./hand-models/hands.json\"\n\nconst handModelGroup = new THREE.ObjectLoader().parse(handsModel)\n\nlet originalCamera\nlet XRSession\nlet controllers = {}\n\nexport function getXRControllers() {\n  return controllers\n}\n\nexport function getXRSession() {\n  return XRSession\n}\n\nexport function getXRCamera() {\n  return renderer.xr.getCamera(originalCamera)\n}\n\nasync function buildController(data) {\n  let geometry, material\n\n  if (data.targetRayMode == \"tracked-pointer\") {\n    if (data.handedness === \"left\") {\n      return handModelGroup.getChildByName(\"left\")\n    }\n    if (data.handedness === \"right\") {\n      return handModelGroup.getChildByName(\"right\")\n    }\n    geometry = new THREE.RingBufferGeometry(0.02, 0.04, 32) //.translate(0, 0, -1)\n    material = new THREE.MeshBasicMaterial({\n      opacity: 0.5,\n      transparent: true,\n      side: THREE.DoubleSide,\n    })\n    return new THREE.Mesh(geometry, material)\n  }\n}\n\nexport function getXRGamepads() {\n  const pads = XRSession && XRSession.inputSources\n  if (pads) {\n    const list = [pads[0], pads[1]].filter((i) => i)\n    const left = list.find((i) => i.handedness === \"left\")\n    const right = list.find((i) => i.handedness === \"right\")\n    if (!left || !right) {\n      return false\n    }\n    return { left, right }\n  }\n  return null\n}\n\nexport function getXRGamepadButtonValue(hand, index) {\n  return getXRGamepads() && getXRGamepads()[hand].gamepad.buttons.map((i) => i.value)[index]\n}\n\nexport async function initXRSession({ renderer, rig, camera }) {\n  originalCamera = camera\n\n  renderer.xr.enabled = true\n  const sessionOptions = { optionalFeatures: [\"local-floor\", \"bounded-floor\", \"hand-tracking\"] }\n  XRSession = await navigator.xr.requestSession(\"immersive-vr\", sessionOptions)\n  if (!XRSession) {\n    console.log(\"session not there\")\n    alert(\"XR Session not started\")\n    return\n  }\n  XRSession.addEventListener(\"end\", function () {\n    console.log(\"session end\")\n    //   GAME_STOPPED = true\n    XRSession = null\n  })\n  renderer.xr.setSession(XRSession)\n\n  for (const index of [0, 1]) {\n    const controller = renderer.xr.getController(index)\n    controller.addEventListener(\"connected\", async function (event) {\n      // console.log(\"connected\", event)\n      const mesh = await buildController(event.data)\n      controllers[event.data.handedness] = {\n        hand: event.data.handedness,\n        mesh: mesh,\n      }\n      this.add(mesh)\n    })\n    controller.addEventListener(\"disconnected\", function () {\n      console.log(\"gamepad disconected...\")\n      this.remove(this.children[0])\n    })\n    rig.add(controller)\n  }\n\n  return await waitUntil(\n    function () {\n      return controllers.left && controllers.right\n    },\n    5000,\n    \"Controllers not loaded (timeout)\"\n  )\n}\n","import hasParent from \"../../_helpers/dom-element-has-parent\"\nimport delay from \"delay\"\nimport deepmerge from \"deepmerge\"\nimport { MaxEquation } from \"three\"\n\nconst BACK_TO_POSITION_ANIMATION_DURATION = 200\nconst JOYSTICK_RADIUS = 80\n\nlet htmlContainer\nconst virtualJoysticks = {\n  left: null,\n  right: null,\n}\n\nconst screenSize = {\n  x: 0,\n  y: 0,\n}\n\nfunction createJoystick(side) {\n  const defaultState = {\n    active: false,\n    touchIdentifier: null,\n    touchStartPosition: {\n      x: 0,\n      y: 0,\n    },\n    innerCirclePosition: {\n      x: 0,\n      y: 0,\n    },\n    vector: {\n      x: 0,\n      y: 0,\n    },\n  }\n  let self = deepmerge({}, defaultState)\n\n  const zone = document.createElement(\"div\")\n  zone.classList.add(\"joystick-zone\")\n  zone.innerHTML = `\n        <div class=\"joystick\">\n        </div>\n        <div class=\"inner-circle\"></div>\n    `\n  const joystickElement = zone.querySelector(\".joystick\")\n  const innerCircleElement = zone.querySelector(\".inner-circle\")\n\n  async function resetZonePosition() {\n    zone.classList.add(\"animate-joystick-start-position\")\n    if (side === \"left\") {\n      zone.style.left = \"15px\"\n      joystickElement.style.top = \"75vh\"\n      joystickElement.style.left = \"20vw\"\n      innerCircleElement.style.top = \"75vh\"\n      innerCircleElement.style.left = \"20vw\"\n    }\n    if (side === \"right\") {\n      zone.style.right = \"15px\"\n      joystickElement.style.top = \"75vh\"\n      joystickElement.style.left = \"80vw\"\n      innerCircleElement.style.top = \"75vh\"\n      innerCircleElement.style.left = \"80vw\"\n    }\n    await delay(BACK_TO_POSITION_ANIMATION_DURATION)\n    zone.classList.remove(\"animate-joystick-start-position\")\n  }\n  resetZonePosition()\n\n  joystickElement.style.bottom = \"20vh\"\n  innerCircleElement.style.bottom = \"20vh\"\n\n  function updateJoystickPosition({ x, y }) {\n    joystickElement.style.top = `${y}px`\n    joystickElement.style.left = `${x}px`\n  }\n\n  function updateInnerCirclePosition({ x, y }) {\n    innerCircleElement.style.top = `${y}px`\n    innerCircleElement.style.left = `${x}px`\n  }\n\n  function intersectLineCircle({ point, circleCenter, radius }) {\n    // console.log(...arguments)\n    // const output = lineCircleCollision(\n    //     [endPoint.x, endPoint.y],\n    //   [startPoint.x, startPoint.y],\n    //   [circleCenter.x, circleCenter.y],\n    //   radius\n    // )\n    const lenX = point.x - circleCenter.x\n    const lenY = point.y - circleCenter.y\n\n    const lineLength = Math.sqrt(\n      (point.x - circleCenter.x) * (point.x - circleCenter.x) +\n        (point.y - circleCenter.y) * (point.y - circleCenter.y)\n    )\n    const alpha = (lineLength - radius) / lineLength\n    // console.log(alpha)\n    if (alpha <= 0) {\n      return false\n    }\n    // return output\n    return {\n      x: point.x + (circleCenter.x - point.x) * alpha,\n      y: point.y + (circleCenter.y - point.y) * alpha,\n    }\n  }\n\n  function getVectorValue({ center, point, radius }) {\n    return {\n      x: (point.x - center.x) / radius,\n      y: (-1 * (point.y - center.y)) / radius,\n    }\n  }\n\n  zone.addEventListener(\"touchstart\", (event) => {\n    // console.log(\"touchstart\", event)\n    joystickElement.classList.add(\"active\")\n    innerCircleElement.classList.add(\"active\")\n    if (self.active) {\n      return\n    }\n    // console.log(event.targetTouches[0].identifier)\n    self.active = true\n    self.touchIdentifier = event.targetTouches[0].identifier\n    self.touchStartPosition.x = event.targetTouches[0].pageX\n    self.touchStartPosition.y = event.targetTouches[0].pageY\n    updateJoystickPosition(self.touchStartPosition)\n    updateInnerCirclePosition(self.touchStartPosition)\n  })\n  zone.addEventListener(\"touchmove\", (event) => {\n    // console.log(\"touchmove\", event.changedTouches.item(self.touchIdentifier))\n    // console.log(\"touchmove\", event.touches.length, event.changedTouches.length, event.targetTouches.length)\n    if (self.active) {\n      let touch\n      for (let i = 0; i < event.touches.length; i++) {\n        if (event.touches[i].identifier === self.touchIdentifier) {\n          touch = event.touches[i]\n          break\n        }\n      }\n      if (!touch) {\n        return\n      }\n      const point = {\n        x: touch.pageX,\n        y: touch.pageY,\n      }\n      const intersection = intersectLineCircle({\n        point,\n        circleCenter: self.touchStartPosition,\n        radius: JOYSTICK_RADIUS,\n      })\n      if (intersection) {\n        self.innerCirclePosition.x = intersection.x\n        self.innerCirclePosition.y = intersection.y\n      } else {\n        self.innerCirclePosition.x = point.x\n        self.innerCirclePosition.y = point.y\n      }\n\n      self.vector = getVectorValue({\n        center: self.touchStartPosition,\n        point: self.innerCirclePosition,\n        radius: JOYSTICK_RADIUS,\n      })\n      updateInnerCirclePosition(self.innerCirclePosition)\n    }\n  })\n  zone.addEventListener(\"touchend\", () => {\n    // console.log(\"touchend\", event)\n    self = deepmerge({}, defaultState)\n    setTimeout(resetZonePosition, 100)\n    joystickElement.classList.remove(\"active\")\n    innerCircleElement.classList.remove(\"active\")\n  })\n\n  return {\n    getVector() {\n      return self.vector\n    },\n    element: zone,\n  }\n}\n\nexport async function initMobileInput() {\n  if (!location.href.includes(\"localhost\")) {\n    const userAgent = window.navigator.userAgent\n    if (!userAgent.match(/iPad/i) && !userAgent.match(/iPhone/i)) {\n      document.documentElement.requestFullscreen()\n    }\n  }\n\n  htmlContainer = document.createElement(\"div\")\n  htmlContainer.classList.add(\"virtual-joysticks\")\n  document.body.appendChild(htmlContainer)\n\n  virtualJoysticks.left = createJoystick(\"left\")\n  htmlContainer.appendChild(virtualJoysticks.left.element)\n\n  virtualJoysticks.right = createJoystick(\"right\")\n  htmlContainer.appendChild(virtualJoysticks.right.element)\n\n  //   document.body.addEventListener(\"touchstart\", (event) => {\n  //     // console.log('touchstart', event)\n  //     if (true) {\n  //       // console.log(event.clientX, event.clientY, screen.width, screen.height)\n  //     }\n  //   })\n  //   document.body.addEventListener(\"touchmove\", (event) => {\n  //     // console.log(\"touchmove\", event.targetTouches)\n  //   })\n  //   document.body.addEventListener(\"touchend\", (event) => {\n  //     // console.log('touchstart', event)\n  //   })\n}\n\nexport function getMobileJoysticksValue() {\n  return {\n    left: virtualJoysticks.left.getVector(),\n    right: virtualJoysticks.right.getVector(),\n  }\n}\n\nif (window) {\n  const style = document.createElement(\"style\")\n  style.innerHTML = `\n    .virtual-joysticks {\n        position: fixed;\n        left: 0;\n        bottom: 0;\n    }\n    .virtual-joysticks .joystick-zone {\n        __background: rgba(0, 255, 0, .3);\n        position: fixed;\n        bottom: 10px;\n        width: calc(35vw - 30px);\n        height: calc(55vh - 30px);\n    }\n    .virtual-joysticks .joystick {\n        width: 1px;\n        height: 1px;\n        position: fixed;\n        transition: opacity 500ms ease;\n        opacity: .3;\n    }\n    .virtual-joysticks .joystick:after {\n        content: \"\";\n        display:block;\n        width: ${JOYSTICK_RADIUS * 2}px;\n        height: ${JOYSTICK_RADIUS * 2}px;\n        background: rgba(255, 255, 255, .2);\n        border: 2px solid rgba(255, 255, 255, .6);\n        border-radius: 50%;\n        transform: translate3d(-50%,-50%,0);\n    }\n    .virtual-joysticks .inner-circle {\n        width: 1px;\n        height: 1px;\n        position: fixed;\n        transition: opacity 500ms ease;\n        opacity: .5;\n    }\n    .virtual-joysticks .inner-circle:after {\n        content: \"\";\n        display:block;\n        width: 50px;\n        height: 50px;\n        background: rgba(255, 255, 255, .4);\n        border-radius: 50%;\n        transform: translate3d(-50%,-50%,0);\n    }\n\n    .animate-joystick-start-position .joystick,\n    .animate-joystick-start-position .inner-circle {\n        transition: ${BACK_TO_POSITION_ANIMATION_DURATION}ms ease;\n    }\n    .virtual-joysticks .joystick.active {\n        opacity: 1;\n    }\n    .virtual-joysticks .inner-circle.active {\n        opacity: 1;\n    }\n`\n  document.head.appendChild(style)\n}\n","import {\n  initXRSession,\n  getXRSession,\n  getXRControllers,\n  getXRGamepads,\n  getXRCamera,\n  getXRGamepadButtonValue,\n} from \"./xr/xr-input\"\n\nimport { initMobileInput, getMobileJoysticksValue } from \"./mobile/mobile-input\"\n\nlet keyboardState = {}\n\nexport function initInputSystem({ renderer }) {\n  document.addEventListener(\n    \"keydown\",\n    (event) => {\n      keyboardState[event.code] = true\n    },\n    false\n  )\n  document.addEventListener(\n    \"keyup\",\n    (event) => {\n      keyboardState[event.code] = false\n    },\n    false\n  )\n}\n\nexport const inputSystem = (window.inputSystem = {\n  // vr\n  initXRSession,\n  getXRControllers,\n  getXRGamepads,\n  getXRSession,\n  getXRCamera,\n  getXRGamepadButtonValue,\n  // mobile\n  initMobileInput,\n  getMobileJoysticksValue,\n  // desktop\n  getKeyboardState() {\n    return keyboardState\n  },\n})\n","import delay from \"delay\"\n\nexport default async function waitUntil(conditionFn, timeout, err) {\n  return new Promise(async function (resolve) {\n    err = err || \"waitUntil : timeout on condition : \" + conditionFn\n    while (!conditionFn()) {\n      //console.log(conditionFn())\n      if (timeout < 0) {\n        throw new Error(err)\n      }\n      await delay(300)\n      timeout -= 300\n    }\n    resolve()\n  })\n}\n","import { inputSystem } from \"../input/input-system\"\nimport * as THREE from \"three\"\nimport { Octree } from \"three/examples/jsm/math/Octree.js\"\nimport { Capsule } from \"three/examples/jsm/math/Capsule.js\"\n\n// Collision system with world octree and body capsule\n// 99.99 % inspired by https://threejs.org/examples/?q=fps#games_fps\n\nexport let collisionSystem\n\nexport function initCollisions({ platformType, collisionObjects, rig }) {\n  const DEFAULT_BODY_HEIGHT = 1.7\n  const DEFAULT_BODY_RADIUS = 0.35\n\n  let rigOnFloor = true\n\n  let worldOctree = new Octree()\n\n  for (const object of collisionObjects) {\n    worldOctree.fromGraphNode(object)\n  }\n\n  const bodyCapsule = new Capsule()\n\n  collisionSystem = {\n    sphereIntersect(sphere) {\n      return worldOctree.sphereIntersect(sphere)\n    },\n    isRigOnFloor() {\n      return rigOnFloor\n    },\n    update(dt) {\n      if (platformType == \"desktop\" || platformType == \"mobile\") {\n        bodyCapsule.set(\n          new THREE.Vector3(rig.position.x, rig.position.y + DEFAULT_BODY_RADIUS, rig.position.z),\n          new THREE.Vector3(\n            rig.position.x,\n            rig.position.y + DEFAULT_BODY_HEIGHT - DEFAULT_BODY_RADIUS,\n            rig.position.z\n          ),\n          DEFAULT_BODY_RADIUS\n        )\n      } // END if \"desktop\"\n\n      if (platformType == \"vr\") {\n        const cameraPosition = inputSystem.getXRCamera().position\n        bodyCapsule.set(\n          new THREE.Vector3(\n            cameraPosition.x,\n            rig.position.y + DEFAULT_BODY_RADIUS,\n            cameraPosition.z\n          ),\n          new THREE.Vector3(\n            cameraPosition.x,\n            cameraPosition.y - DEFAULT_BODY_RADIUS,\n            cameraPosition.z\n          ),\n          DEFAULT_BODY_RADIUS\n        )\n      }\n\n      rigOnFloor = false\n      const result = worldOctree.capsuleIntersect(bodyCapsule)\n      if (result) {\n        window.debug = result.normal.y\n        rigOnFloor = result.normal.y > 0.3\n        const vector = result.normal.multiplyScalar(result.depth)\n        rig.position.add(vector)\n      }\n    },\n  }\n}\n","import * as THREE from \"three\"\nimport { inputSystem } from \"../../../input/input-system\"\nimport { collisionSystem } from \"../../../collisions/collisions\"\nimport { locomotionSystem } from \"../../locomotion\"\n\nexport function initClimbingVRSystem({ platformType, rig }) {\n  if (platformType != \"vr\") {\n    return\n  }\n  // used to compute velocity when detaching hands from walls\n  const lastBodyPositions = []\n  let climbingState = {\n    grippedHand: null,\n    canGrip: {\n      left: true,\n      right: true,\n    },\n    position: new THREE.Vector3(0, 0, 0),\n  }\n  const xrHands = inputSystem.getXRControllers()\n\n  return (climbingVRSystem = {\n    update(deltaTime) {\n      const rigVelocity = locomotionSystem.getRigVelocity()\n\n      for (const handName of [\"left\", \"right\"]) {\n        if (inputSystem.getXRGamepadButtonValue(handName, 1) < 0.5) {\n          //console.log('handName')\n          if (climbingState.grippedHand == handName) {\n            climbingState.grippedHand = null\n          }\n          climbingState.canGrip[handName] = true\n        }\n      }\n\n      if (climbingState.grippedHand) {\n        // console.log(\"climbingState.grippedHand\")\n        const handPosition = new THREE.Vector3()\n        xrHands[climbingState.grippedHand].mesh.getWorldPosition(handPosition)\n        rig.position.add(climbingState.position.clone().sub(handPosition))\n\n        lastBodyPositions.push({\n          position: rig.position.clone(),\n          dt: deltaTime,\n        })\n        if (lastBodyPositions.length > 2) {\n          lastBodyPositions.splice(0, 1)\n        }\n      }\n\n      for (const handName of [\"left\", \"right\"]) {\n        if (!climbingState.canGrip[handName]) {\n          continue\n        }\n\n        // get grip value for the hand\n        if (inputSystem.getXRGamepadButtonValue(handName, 1) < 0.5) {\n          continue\n        }\n\n        // if one hand already gripped we do nothing\n        if (climbingState.grippedHand == handName) {\n          continue\n        }\n\n        const handPosition = new THREE.Vector3(0, 0, 0)\n        xrHands[handName].mesh.getWorldPosition(handPosition)\n        const result = collisionSystem.sphereIntersect(new THREE.Sphere(handPosition, 0.1))\n        if (result) {\n          climbingState.grippedHand = handName\n          climbingState.position = handPosition\n          climbingState.canGrip[handName] = false\n\n          rigVelocity.x = 0\n          rigVelocity.y = 0\n          rigVelocity.z = 0\n          break\n        }\n      }\n\n      // for (const handName of [\"left\", \"right\"]) {\n      //   if (climbingState.grippedHand == handName) {\n      //     xrHands[handName].mesh.material.color.set(0xff1111)\n      //     continue\n      //   }\n      //   xrHands[handName].mesh.material.color.set(0x11ff11)\n      // }\n\n      // when player relax grip, add inertia towards movement direction (allow player to fast climb a wall)\n      if (climbingState.grippedHand === null && lastBodyPositions.length > 1) {\n        rigVelocity.x =\n          ((lastBodyPositions[1].position.x - lastBodyPositions[0].position.x) * 0.7) / deltaTime\n        rigVelocity.y =\n          ((lastBodyPositions[1].position.y - lastBodyPositions[0].position.y) * 0.7) / deltaTime\n        rigVelocity.z =\n          ((lastBodyPositions[1].position.z - lastBodyPositions[0].position.z) * 0.7) / deltaTime\n        lastBodyPositions.splice(0)\n      }\n    },\n    isClimbing() {\n      return climbingState.grippedHand !== null\n    },\n  })\n}\n\nexport let climbingVRSystem\n","import * as THREE from \"three\"\nimport { inputSystem } from \"../../../input/input-system\"\nimport { locomotionSystem } from \"../../../locomotion/locomotion\"\nimport { collisionSystem } from \"../../../collisions/collisions\"\n\nexport let flyingVRSystem\n\nexport function initFlyingVRSystem({ platformType, rig }) {\n  if (platformType != \"vr\") {\n    return\n  }\n\n  let canFly = false\n\n  function getFlyingForwardVector() {\n    const leftHandPosition = new THREE.Vector3()\n    const rightHandPosition = new THREE.Vector3()\n\n    const hands = inputSystem.getXRControllers()\n    hands.left.mesh.parent.getWorldPosition(leftHandPosition)\n    hands.right.mesh.parent.getWorldPosition(rightHandPosition)\n    return leftHandPosition\n      .clone()\n      .sub(rightHandPosition)\n      .normalize()\n      .cross(new THREE.Vector3(0, 1, 0))\n      .normalize()\n  }\n\n  function handsInFlyingPosition() {\n    const hands = inputSystem.getXRControllers()\n    const distanceOk =\n      hands.left.mesh.parent.position.distanceTo(hands.right.mesh.parent.position) > 1.1\n\n    const leftHandPosition = hands.left.mesh.parent.position\n    const rightHandPosition = hands.right.mesh.parent.position\n\n    // playerInput.getXRCamera().position.distanceTo()\n    const angleOk = Math.abs(leftHandPosition.clone().sub(rightHandPosition).normalize().y) < 0.8\n\n    return distanceOk && angleOk\n  }\n\n  return (flyingVRSystem = window.flyingVRSystem = {\n    isFlying() {\n      return canFly\n    },\n    update(deltaTime) {\n      if (collisionSystem.isRigOnFloor() === true) {\n        canFly = false\n        return\n      }\n      const rigVelocity = locomotionSystem.getRigVelocity()\n      canFly = handsInFlyingPosition()\n      //playerInput.getKeyStates().ShiftLeft\n      if (canFly) {\n        //   console.log(getFlyingForwardVector())\n        //   debugger\n        rigVelocity.copy(getFlyingForwardVector().multiplyScalar(10))\n        rigVelocity.y = -3\n      }\n      // FLYING DAMPING\n      //   playerVelocity.y -= 65 * deltaTime\n      //   const damping = Math.exp(-25 * deltaTime) - 1\n      //   playerVelocity.addScaledVector(playerVelocity, damping)\n    },\n  })\n}\n","import * as THREE from \"three\"\nimport { collisionSystem } from \"../collisions/collisions\"\n\nimport { initClimbingVRSystem, climbingVRSystem } from \"./systems/climb-vr/climb-vr\"\nimport { initFlyingVRSystem, flyingVRSystem } from \"./systems/fly-vr/fly-vr\"\n\nconst GRAVITY_FACTOR = 9.81\n\nexport let locomotionSystem\n\nexport function initLocomotion({ platformType, features, overlay, camera, rig, scene }) {\n  window.collisionSystem = collisionSystem\n  let rigVelocity = (window.rigVelocity = new THREE.Vector3(0, 0, 0))\n\n  const systems = []\n  for (const feature of features) {\n    const system = feature({ platformType, camera, rig, scene })\n    if (system) {\n      systems.push(system)\n    }\n  }\n\n  locomotionSystem = {\n    getCamera() {\n      return camera\n    },\n    getRigVelocity() {\n      return rigVelocity\n    },\n    update(deltaTime) {\n      for (const system of systems) {\n        system.update(deltaTime)\n      }\n\n      // gravity\n      if (collisionSystem.isRigOnFloor()) {\n        // continue\n      } else if (climbingVRSystem && climbingVRSystem.isClimbing() === true) {\n        return\n      } else if (flyingVRSystem && flyingVRSystem.isFlying() === true) {\n        // continue\n      } else {\n        rigVelocity.y -= GRAVITY_FACTOR * deltaTime\n        const horizontalDamping = Math.exp(-0.5 * deltaTime)\n        rigVelocity.x = rigVelocity.x * horizontalDamping\n        rigVelocity.z = rigVelocity.z * horizontalDamping\n      }\n\n      // update position from velocity vector\n      const deltaPosition = rigVelocity.clone().multiplyScalar(deltaTime)\n      rig.position.add(deltaPosition)\n    },\n  }\n}\n","import { inputSystem } from \"../../../input/input-system\"\nimport { collisionSystem } from \"../../../collisions/collisions\"\nimport { locomotionSystem } from \"../../locomotion\"\nimport * as THREE from \"three\"\n\nconst SPEED = 3\nconst INERTIA_FACTOR = 0.7\n\nexport function initWalkingSystem({ platformType, rig, speedFactor = 1 }) {\n  const desktopKeyboardState = {}\n  const eulerAngle = new THREE.Euler(0, 0, 0, \"YXZ\")\n  const minPolarAngle = 0\n  const maxPolarAngle = Math.PI\n\n  if (platformType == \"desktop\" || platformType == \"mobile\") {\n    //locomotionSystem.getCamera().rotation.order = \"YXZ\"\n  }\n\n  function rotateCamera({ deltaX, deltaY }) {\n    eulerAngle.setFromQuaternion(camera.quaternion)\n    eulerAngle.y -= deltaX\n    eulerAngle.x -= deltaY\n    eulerAngle.x = Math.max(\n      Math.PI / 2 - maxPolarAngle,\n      Math.min(Math.PI / 2 - minPolarAngle, eulerAngle.x)\n    )\n    locomotionSystem.getCamera().quaternion.setFromEuler(eulerAngle)\n  }\n\n  if (platformType == \"desktop\") {\n    document.body.requestPointerLock()\n    document.body.addEventListener(\n      \"mousemove\",\n      (event) => {\n        if (document.pointerLockElement === document.body) {\n          // camera.rotation.y -= event.movementX / 500\n          // camera.rotation.x -= -event.movementY / 500\n          rotateCamera({ deltaX: event.movementX * 0.002, deltaY: event.movementY * 0.002 })\n        }\n      },\n      false\n    )\n  }\n\n  function getSideVector() {\n    const direction = getForwardVector(camera)\n    direction.cross(locomotionSystem.getCamera().up)\n    return direction\n  }\n\n  function getForwardVector() {\n    const direction = new THREE.Vector3()\n    if (platformType == \"desktop\" || platformType == \"mobile\") {\n      locomotionSystem.getCamera().getWorldDirection(direction)\n      direction.y = 0\n    }\n    if (platformType == \"vr\") {\n      inputSystem.getXRControllers().left.mesh.parent.getWorldDirection(direction)\n      direction.multiplyScalar(-1)\n      direction.y = 0\n    }\n    direction.normalize()\n    return direction\n  }\n\n  return (walkingSystem = {\n    update(deltaTime) {\n      const rigVelocity = locomotionSystem.getRigVelocity()\n      if (platformType == \"mobile\") {\n        rotateCamera({\n          deltaX: inputSystem.getMobileJoysticksValue().right.x / 30,\n          deltaY: (-1 * inputSystem.getMobileJoysticksValue().right.y) / 50,\n        })\n      }\n\n      if (!collisionSystem.isRigOnFloor()) {\n        return\n      }\n\n      let forwardValue = 0\n      let sideValue = 0\n\n      if (platformType == \"desktop\") {\n        const keys = inputSystem.getKeyboardState()\n        const forward = keys[\"KeyW\"] || keys[\"ArrowUp\"] ? 1 : 0\n        const backward = keys[\"KeyS\"] || keys[\"ArrowDown\"] ? -1 : 0\n        const right = keys[\"KeyD\"] || keys[\"ArrowRight\"] ? 1 : 0\n        const left = keys[\"KeyA\"] || keys[\"ArrowLeft\"] ? -1 : 0\n        forwardValue = forward + backward\n        sideValue = left + right\n        sideValue = sideValue / 1.5\n      }\n\n      if (platformType == \"mobile\") {\n        forwardValue = inputSystem.getMobileJoysticksValue().left.y\n        sideValue = inputSystem.getMobileJoysticksValue().left.x\n\n        // camera.rotation.y -= inputSystem.getMobileJoysticksValue().right.x / 30\n        // camera.rotation.x -= inputSystem.getMobileJoysticksValue().right.y / 30\n      }\n\n      if (platformType == \"vr\") {\n        forwardValue = inputSystem.getXRGamepads().left.gamepad.axes[3] * -1\n        sideValue = inputSystem.getXRGamepads().left.gamepad.axes[2]\n      }\n\n      const deltaPosition = new THREE.Vector3(0, 0, 0)\n      deltaPosition\n        .add(getForwardVector().multiplyScalar(forwardValue))\n        .add(getSideVector().multiplyScalar(sideValue))\n        // .normalize()\n        .multiplyScalar(SPEED * speedFactor)\n      rigVelocity.add(deltaPosition)\n\n      // rigVelocity.copy(deltaPosition)\n\n      // const damping = Math.exp(-1.0001) - 1\n      // rigVelocity.addScaledVector(rigVelocity, damping)\n      rigVelocity.multiplyScalar(INERTIA_FACTOR)\n    },\n    isWalking() {\n      return (\n        collisionSystem.isRigOnFloor() &&\n        Math.abs(rigVelocity.x) + Math.abs(rigVelocity.y) + Math.abs(rigVelocity.z) > 0.05\n      )\n    },\n  })\n  window.walkingSystem = walkingSystem\n}\n\nexport let walkingSystem\n","import * as THREE from \"three\"\nimport { initCollisions, collisionSystem } from \"./collisions/collisions\"\nimport { initLocomotion, locomotionSystem } from \"./locomotion/locomotion\"\nimport deepMerge from \"deepmerge\"\nimport { initUiOverlay, uiOverlay } from \"./ui-overlay/ui-overlay\"\nimport { initInputSystem, inputSystem } from \"./input/input-system\"\n\nimport { initWalkingSystem, walkingSystem } from \"./locomotion/systems/walk/walk\"\nimport { initSnapTurnVRSystem, snapTurnVRSystem } from \"./locomotion/systems/snap-turn-vr/snap-turn-vr\"\nimport { initClimbingVRSystem, climbingVRSystem } from \"./locomotion/systems/climb-vr/climb-vr\"\nimport { initFlyingVRSystem, flyingVRSystem } from \"./locomotion/systems/fly-vr/fly-vr\"\nimport { initTeleportVRSystem, teleportVRSystem } from \"./locomotion/systems/teleport-vr/teleport-vr\"\n\n// detect context before loading\nlet platformType // 'vr', 'desktop', 'mobile'\n\nif (window) {\n  ;(async () => {\n    platformType = \"desktop\"\n    const agent = window.navigator.userAgent\n    if (agent.includes(\"Quest\")) {\n      // if (await navigator.xr.isSessionSupported(\"immersive-vr\")) {\n      platformType = \"vr\"\n    } else {\n      if (window.document) {\n        function detectMobile() {\n          platformType = \"mobile\"\n          window.document.removeEventListener(\"touchstart\", detectMobile)\n        }\n        window.document.addEventListener(\"touchstart\", detectMobile)\n      }\n    }\n    //alert(platformType)\n  })()\n}\n\nexport default async function ({ collisionObjects, scene, rig, camera, renderer, features }) {\n  let overlay\n\n  if (!platformType) {\n    throw new Error(\n      \"Cannot detect platformType, you must handle at least an user-based click before starting locomotion system\"\n    )\n  }\n\n  //   console.log(deepMerge({foo: 'bar', mdr: 'dssq'}, { mdr: 'iiiii' }))\n\n  initInputSystem({ renderer })\n\n  if (platformType === \"vr\") {\n    console.log(\"init vr session\")\n    await inputSystem.initXRSession({ renderer, rig, camera })\n    console.log(\"VR session started\")\n  }\n\n  if (platformType === \"mobile\") {\n    // alert()\n    await inputSystem.initMobileInput()\n    //inputSystem.getMobileJoysticksValue()\n  }\n\n  initCollisions({ platformType, collisionObjects, rig })\n  initLocomotion({ platformType, features, overlay, camera, rig, scene })\n\n  // await new Promise(r => setTimeout(r, 4000))\n  return {\n    update(deltaTime) {\n      if (deltaTime > 1) {\n        deltaTime = 1\n      }\n      // console.log(inputSystem.getKeyboardState())\n      locomotionSystem.update(deltaTime)\n      collisionSystem.update(deltaTime)\n    },\n    on() {},\n    getPlatformType: () => platformType,\n  }\n}\n\nexport function walk(options) {\n  return function ({ rig, camera, platformType, scene }) {\n    return initWalkingSystem({ ...options, rig, camera, platformType, scene })\n  }\n}\nexport function snapTurnVR(options) {\n  return function ({ rig, camera, platformType, scene }) {\n    return initSnapTurnVRSystem({ ...options, rig, camera, platformType, scene })\n  }\n}\nexport function climbVR(options) {\n  return function ({ rig, camera, platformType, scene }) {\n    return initClimbingVRSystem({ ...options, rig, camera, platformType, scene })\n  }\n}\nexport function flyVR(options) {\n  return function ({ rig, camera, platformType, scene }) {\n    return initFlyingVRSystem({ ...options, rig, camera, platformType, scene })\n  }\n}\nexport function teleportVR(options) {\n  return function ({ rig, camera, platformType, scene }) {\n    return initTeleportVRSystem({ ...options, rig, camera, platformType, scene })\n  }\n}\n","import universalLocomotion, { walk, snapTurnVR, climbVR, flyVR, teleportVR } from '../src/index'\nimport { GLTFLoader } from \"three/examples/jsm/loaders/GLTFLoader.js\"\nimport * as THREE from \"three\"\n\nfunction addStartButton(onStart) {\n    document.body.innerHTML = \"\"\n    const startButton = document.createElement('div')\n    startButton.innerHTML = \"START\"\n    startButton.style.fontSize = '30px';\n    startButton.style.cursor = 'pointer';\n    startButton.style.background = 'white';\n    startButton.style.padding = '15px 20px';\n    startButton.style.color = 'black';\n    startButton.style.fontWeight = 'bold';\n    startButton.style.position = 'fixed';\n    startButton.style.top = '50%';\n    startButton.style.left = '50%';\n    startButton.style.transform = 'translate3d(-50%, -50%, 0)';\n    document.body.appendChild(startButton)\n    startButton.addEventListener('click', () => {\n        startButton.remove()\n        onStart()\n    })\n}\n\nlet scene, camera, renderer, locomotion\n\nwindow.openExample1 = () => {\n    const loader = new GLTFLoader().setPath('./')\n    loader.load('demo-scene/demo-scene.glb', function (gltf) {\n        console.log('demo scene loaded')\n        // console.log(gltf.scene)\n\n        addStartButton( async function onStart() {\n\n            //alert(locomotion.getContext())\n            // scene\n            scene = new THREE.Scene()\n            scene.background = new THREE.Color(0xabcdef)\n\n            // camera\n            camera = window.camera = new THREE.PerspectiveCamera(\n                50,\n                window.innerWidth / window.innerHeight,\n                0.1,\n                100000\n            )\n            camera.position.set(0, 1.7, 0)\n            camera.lookAt(100, 0, 100)\n            // scene.add(camera)\n\n            // renderer\n            renderer = window.renderer = new THREE.WebGLRenderer({ antialias: false })\n            renderer.setPixelRatio(window.devicePixelRatio)\n            renderer.setSize(window.innerWidth, window.innerHeight)\n            renderer.outputEncoding = THREE.sRGBEncoding\n            function onWindowResize() {\n                camera.aspect = window.innerWidth / window.innerHeight\n                camera.updateProjectionMatrix()\n                renderer.setSize(window.innerWidth, window.innerHeight)\n            }\n            window.addEventListener(\"resize\", onWindowResize, false)\n            // renderer.xr.enabled = true\n            document.body.appendChild(renderer.domElement)\n\n            // lighting\n//            const ambientLight = new THREE.AmbientLight(0x5555ff)\n //           ambientLight.intensity = 0.5\n  //          scene.add(ambientLight)\n\n            const light = new THREE.HemisphereLight( 0x4444ff, 0x111111, 1 );\n            scene.add( light );\n\n            const directionalLight = new THREE.DirectionalLight(0xff4444, 1)\n            directionalLight.position.set(-15, 25, -5)\n            scene.add( directionalLight );\n\n            // fog\n            scene.fog = new THREE.Fog(0xabcdef, 0, 190)\n            // scene.fog = new THREE.FogExp2(0xffffff, .014)\n\n            // create body rig\n            const rig = window.debugRig = new THREE.Group()\n            rig.position.set(0, 0, 0)\n            scene.add(rig)\n            rig.add(camera)\n\n            // add scene\n            scene.add(gltf.scene)\n\n            // init locomotion\n            const locomotion = await universalLocomotion({\n                collisionObjects: [gltf.scene], // collision meshes,\n                scene,\n                renderer,\n                camera,\n                rig,\n                features: [\n                    walk({ speedFactor: 1 }),\n                    // teleportVR(),\n                    snapTurnVR(),\n                    climbVR(),\n                    flyVR()\n                ]\n            })\n            \n            const clock = new THREE.Clock()\n            // let i = 0\n            renderer.setAnimationLoop(function () {\n                    \n                \n            // setInterval(() => {\n                //console.log(clock)\n                // if (i%3 == 0) {\n                    const deltaTime = clock.getDelta() // in seconds\n                    locomotion.update(deltaTime)\n                // }\n                // i++\n                renderer.render(scene, camera)\n            // }, 1000/20)\n            })\n\n            window.renderer1 = renderer\n            window.THREE = THREE\n                \n        }) //onStart\n    })\n}","import { inputSystem } from \"../../../input/input-system\"\nimport rotateAboutPoint from \"../../../_helpers/rotate-about-point\"\n\nexport function initSnapTurnVRSystem({ platformType, rig }) {\n  if (platformType != \"vr\") {\n    return\n  }\n  let lastXRSnapTurnTime = 0\n\n  return (snapTurnVRSystem = {\n    update(deltaTime) {\n      if (new Date().getTime() - lastXRSnapTurnTime > 200) {\n        const gamepads = inputSystem.getXRGamepads()\n\n        if (Math.abs(gamepads.right.gamepad.axes[2]) > 0.3) {\n          const way = gamepads.right.gamepad.axes[2] > 0 ? -1 : 1\n          rotateAboutPoint(\n            rig,\n            inputSystem.getXRCamera().position,\n            new THREE.Vector3(0, 1, 0),\n            (way * Math.PI) / 8,\n            false\n          )\n          lastXRSnapTurnTime = new Date().getTime()\n        }\n      }\n    },\n  })\n}\n\nexport let snapTurnVRSystem\n","import * as THREE from \"three\"\n\nexport default function rotateAboutPoint(obj, point, axis, theta, pointIsWorld) {\n  pointIsWorld = pointIsWorld === undefined ? false : pointIsWorld\n\n  if (pointIsWorld) {\n    obj.parent.localToWorld(obj.position) // compensate for world coordinate\n  }\n\n  obj.position.sub(point) // remove the offset\n  obj.position.applyAxisAngle(axis, theta) // rotate the POSITION\n  obj.position.add(point) // re-add the offset\n\n  if (pointIsWorld) {\n    obj.parent.worldToLocal(obj.position) // undo world coordinates compensation\n  }\n\n  obj.rotateOnAxis(axis, theta) // rotate the OBJECT\n}\n\n// @SEE\n// THREE.Object3D.prototype.rotateAroundWorldAxis = function() {\n\n//     // rotate object around axis in world space (the axis passes through point)\n//     // axis is assumed to be normalized\n//     // assumes object does not have a rotated parent\n\n//     var q = new THREE.Quaternion();\n\n//     return function rotateAroundWorldAxis( point, axis, angle ) {\n\n//         q.setFromAxisAngle( axis, angle );\n\n//         this.applyQuaternion( q );\n\n//         this.position.sub( point );\n//         this.position.applyQuaternion( q );\n//         this.position.add( point );\n\n//         return this;\n\n//     }\n\n// }();\n"],"names":["modulePath","importFunctionName","Function","error","baseURL","URL","location","cleanup","script","revokeObjectURL","src","remove","url","Promise","resolve","reject","absURL","self","moduleMap","moduleBlob","Blob","type","Object","assign","document","createElement","createObjectURL","[object Object]","Error","head","appendChild","p","handModelGroup","THREE.ObjectLoader","parse","handsModel","originalCamera","XRSession","controllers","async","data","geometry","material","targetRayMode","handedness","getChildByName","THREE.RingBufferGeometry","THREE.MeshBasicMaterial","opacity","transparent","side","THREE.DoubleSide","THREE.Mesh","pads","inputSources","list","filter","i","left","find","right","htmlContainer","virtualJoysticks","defaultState","active","touchIdentifier","touchStartPosition","x","y","innerCirclePosition","vector","self2","deepmerge","zone","classList","add","innerHTML","joystickElement","querySelector","innerCircleElement","style","top","delay","bottom","addEventListener","event","targetTouches","identifier","pageX","pageY","touch","touches","length","point","intersection","circleCenter","radius","lineLength","Math","sqrt","alpha","intersectLineCircle","center","getVectorValue","resetZonePosition","getVector","element","window","keyboardState","inputSystem","initXRSession","renderer","rig","camera","camera2","xr","enabled","navigator","requestSession","optionalFeatures","log","setSession","index","controller","renderer2","getController","mesh","buildController","hand","this","children","conditionFn","timeout","err","waitUntil","getXRControllers","getXRGamepads","getXRSession","getXRCamera","getCamera","getXRGamepadButtonValue","gamepad","buttons","map","value","initMobileInput","href","includes","userAgent","match","documentElement","requestFullscreen","body","createJoystick","getMobileJoysticksValue","getKeyboardState","collisionSystem","climbingVRSystem","flyingVRSystem","platformType","platformType2","canFly","isFlying","deltaTime","isRigOnFloor","rigVelocity2","locomotionSystem","getRigVelocity","hands","distanceOk","parent","position","distanceTo","leftHandPosition","rightHandPosition","angleOk","abs","clone","sub","normalize","handsInFlyingPosition","copy","THREE.Vector3","getWorldPosition","cross","getFlyingForwardVector","multiplyScalar","speedFactor","eulerAngle","THREE.Euler","maxPolarAngle","PI","deltaX","deltaY","setFromQuaternion","quaternion","max","min","setFromEuler","direction","getWorldDirection","requestPointerLock","pointerLockElement","movementX","movementY","forwardValue","sideValue","keys","forward","backward","axes","deltaPosition","getForwardVector","up","getSideVector","isWalking","rigVelocity","z","scene","collisionObjects","features","code","DEFAULT_BODY_RADIUS","rigOnFloor","worldOctree","Octree","object2","fromGraphNode","bodyCapsule","Capsule","sphereIntersect","sphere","dt","set","cameraPosition","result","capsuleIntersect","debug","normal","depth","overlay","systems","feature","system","push","update","isClimbing","horizontalDamping","exp","getPlatformType","options","lastXRSnapTurnTime","Date","getTime","gamepads","way","obj","axis","THREE","Vector3","theta","pointIsWorld","localToWorld","applyAxisAngle","worldToLocal","rotateOnAxis","initSnapTurnVRSystem","__assign","lastBodyPositions","climbingState","grippedHand","canGrip","xrHands","handName","handPosition","splice","THREE.Sphere","initClimbingVRSystem","initFlyingVRSystem","detectMobile","removeEventListener","openExample1","GLTFLoader","setPath","load","gltf","onStart","startButton","fontSize","cursor","background","padding","color","fontWeight","transform","THREE.Scene","THREE.Color","THREE.PerspectiveCamera","innerWidth","innerHeight","lookAt","THREE.WebGLRenderer","antialias","setPixelRatio","devicePixelRatio","setSize","outputEncoding","THREE.sRGBEncoding","aspect","updateProjectionMatrix","domElement","light","THREE.HemisphereLight","directionalLight","THREE.DirectionalLight","fog","THREE.Fog","debugRig","THREE.Group","locomotion","universalLocomotion","initWalkingSystem","snapTurnVR","climbVR","flyVR","clock","THREE.Clock","setAnimationLoop","getDelta","render","renderer1"],"mappings":"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"}